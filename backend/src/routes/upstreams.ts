import { Router } from 'express';
import { writeFile } from 'fs/promises';
import { UpstreamProxy } from '../database';
import { authMiddleware, adminMiddleware, AuthRequest } from '../middleware/auth';

const router = Router();

const UPSTREAM_CONFIG_PATH = '/etc/squid/conf.d/upstreams.conf';

// Known proxy providers with their configuration patterns
const PROXY_PROVIDERS: Record<string, {
  name: string;
  type: 'vpn' | 'residential' | 'datacenter';
  urlPattern: RegExp;
  parseUrl: (url: string) => { host: string; port: number; username?: string; password?: string } | null;
  supportsLocations: boolean;
}> = {
  webshare: {
    name: 'Webshare',
    type: 'residential',
    urlPattern: /webshare|proxy\.webshare\.io/i,
    parseUrl: (url: string) => parseProxyUrl(url),
    supportsLocations: true,
  },
  pia: {
    name: 'Private Internet Access',
    type: 'vpn',
    urlPattern: /privateinternetaccess|pia/i,
    parseUrl: (url: string) => parseProxyUrl(url),
    supportsLocations: true,
  },
  brightdata: {
    name: 'Bright Data',
    type: 'residential',
    urlPattern: /brightdata|luminati|brd\.superproxy/i,
    parseUrl: (url: string) => parseProxyUrl(url),
    supportsLocations: true,
  },
  oxylabs: {
    name: 'Oxylabs',
    type: 'residential',
    urlPattern: /oxylabs/i,
    parseUrl: (url: string) => parseProxyUrl(url),
    supportsLocations: true,
  },
  smartproxy: {
    name: 'Smartproxy',
    type: 'residential',
    urlPattern: /smartproxy/i,
    parseUrl: (url: string) => parseProxyUrl(url),
    supportsLocations: true,
  },
};

// Parse a proxy URL pattern like: http://user:pass@host:port or socks5://host:port
function parseProxyUrl(url: string): { host: string; port: number; username?: string; password?: string; protocol?: string } | null {
  try {
    // Handle URLs without protocol
    let urlToParse = url;
    if (!url.includes('://')) {
      urlToParse = 'http://' + url;
    }
    
    const parsed = new URL(urlToParse);
    const port = parsed.port ? parseInt(parsed.port) : (parsed.protocol === 'socks5:' ? 1080 : 8080);
    
    return {
      host: parsed.hostname,
      port,
      username: parsed.username || undefined,
      password: parsed.password || undefined,
      protocol: parsed.protocol?.replace(':', ''),
    };
  } catch (e) {
    return null;
  }
}

// Detect provider from URL
function detectProvider(url: string): string | null {
  for (const [key, provider] of Object.entries(PROXY_PROVIDERS)) {
    if (provider.urlPattern.test(url)) {
      return key;
    }
  }
  return null;
}

// Generate Squid upstream configuration
async function generateUpstreamConfig(): Promise<string> {
  const proxies = await UpstreamProxy.findAll({
    where: { enabled: true },
    order: [['priority', 'DESC']],
  });

  if (proxies.length === 0) {
    return '# No upstream proxies configured\n';
  }

  let config = '# Upstream Proxy Configuration\n';
  config += '# Auto-generated by Squache backend\n\n';

  proxies.forEach((proxy, index) => {
    if (!proxy.host || !proxy.port) return;
    
    const peerName = `peer_${proxy.id}`;
    
    // Define cache_peer for each upstream proxy
    if (proxy.username && proxy.password) {
      config += `cache_peer ${proxy.host} parent ${proxy.port} 0 no-query login=${proxy.username}:${proxy.password} name=${peerName}\n`;
    } else {
      config += `cache_peer ${proxy.host} parent ${proxy.port} 0 no-query name=${peerName}\n`;
    }

    // Create ACL for this proxy type
    if (proxy.type) {
      config += `acl upstream_${proxy.type} req_header X-Squache-Upstream ${proxy.type}\n`;
    }
    
    // Use countryFilter if set, otherwise fall back to country
    const countryCode = proxy.countryFilter || proxy.country;
    if (countryCode) {
      config += `acl upstream_country_${countryCode.toLowerCase()} req_header X-Squache-Country ${countryCode}\n`;
    }
  });

  config += '\n# Routing rules\n';
  
  // Add routing rules based on headers
  proxies.forEach((proxy) => {
    if (!proxy.host || !proxy.port) return;
    
    const peerName = `peer_${proxy.id}`;
    const countryCode = proxy.countryFilter || proxy.country;
    
    if (countryCode) {
      config += `cache_peer_access ${peerName} allow upstream_${proxy.type} upstream_country_${countryCode.toLowerCase()}\n`;
    } else if (proxy.type) {
      config += `cache_peer_access ${peerName} allow upstream_${proxy.type}\n`;
    }
    config += `cache_peer_access ${peerName} deny all\n`;
  });

  config += '\n# Default to direct connections\n';
  config += 'always_direct allow all\n';

  return config;
}

// Get list of known providers
router.get('/providers', authMiddleware, async (req, res) => {
  const providers = Object.entries(PROXY_PROVIDERS).map(([key, provider]) => ({
    id: key,
    name: provider.name,
    type: provider.type,
    supportsLocations: provider.supportsLocations,
  }));
  res.json(providers);
});

// Parse a proxy URL to extract details
router.post('/parse-url', authMiddleware, async (req, res) => {
  try {
    const { url } = req.body;
    
    if (!url) {
      return res.status(400).json({ error: 'URL is required' });
    }
    
    const parsed = parseProxyUrl(url);
    if (!parsed) {
      return res.status(400).json({ error: 'Invalid proxy URL format' });
    }
    
    const detectedProvider = detectProvider(url);
    const providerInfo = detectedProvider ? PROXY_PROVIDERS[detectedProvider] : null;
    
    res.json({
      ...parsed,
      detectedProvider,
      providerName: providerInfo?.name || null,
      providerType: providerInfo?.type || null,
      supportsLocations: providerInfo?.supportsLocations || false,
    });
  } catch (error) {
    console.error('Parse URL error:', error);
    res.status(500).json({ error: 'Failed to parse proxy URL' });
  }
});

// List upstream proxies
router.get('/', authMiddleware, async (req, res) => {
  try {
    const proxies = await UpstreamProxy.findAll({
      order: [['priority', 'DESC'], ['name', 'ASC']],
      attributes: { exclude: ['password'] },
    });

    res.json(proxies);
  } catch (error) {
    console.error('Upstreams list error:', error);
    res.status(500).json({ error: 'Failed to list upstream proxies' });
  }
});

// Add upstream proxy
router.post('/', authMiddleware, adminMiddleware, async (req: AuthRequest, res) => {
  try {
    const { 
      name, 
      proxyUrl, 
      type,
      provider,
      host,
      port,
      username,
      password,
      countryFilter,
      cityFilter,
      enabled,
      priority 
    } = req.body;

    if (!name) {
      return res.status(400).json({ error: 'Name is required' });
    }

    // Determine connection details
    let finalHost = host;
    let finalPort = port;
    let finalUsername = username;
    let finalPassword = password;
    let finalProvider = provider;
    let finalType = type || 'datacenter';
    
    // If proxy URL is provided, parse it
    if (proxyUrl) {
      const parsed = parseProxyUrl(proxyUrl);
      if (!parsed) {
        return res.status(400).json({ error: 'Invalid proxy URL format. Expected format: http://user:pass@host:port or host:port' });
      }
      
      finalHost = parsed.host;
      finalPort = parsed.port;
      finalUsername = parsed.username || finalUsername;
      finalPassword = parsed.password || finalPassword;
      
      // Auto-detect provider if not specified
      if (!finalProvider) {
        const detected = detectProvider(proxyUrl);
        if (detected) {
          finalProvider = detected;
          finalType = PROXY_PROVIDERS[detected].type;
        }
      }
    }

    // Validate we have connection details
    if (!finalHost || !finalPort) {
      return res.status(400).json({ error: 'Either proxyUrl or host/port must be provided' });
    }

    const proxy = await UpstreamProxy.create({
      name,
      type: finalType,
      provider: finalProvider || null,
      host: finalHost,
      port: finalPort,
      username: finalUsername || null,
      password: finalPassword || null,
      proxyUrl: proxyUrl || null,
      countryFilter: countryFilter?.toUpperCase() || null,
      cityFilter: cityFilter || null,
      country: countryFilter?.toUpperCase() || null,  // Keep in sync for backwards compat
      city: cityFilter || null,
      enabled: enabled !== false,
      priority: priority || 0,
    });

    // Regenerate Squid config
    try {
      const config = await generateUpstreamConfig();
      await writeFile(UPSTREAM_CONFIG_PATH, config);
      console.log('Upstream config regenerated');
      // TODO: Signal Squid to reload config
    } catch (configError) {
      console.error('Failed to update Squid config:', configError);
    }

    res.status(201).json({
      ...proxy.toJSON(),
      password: undefined,
    });
  } catch (error: any) {
    console.error('Upstream create error:', error);
    if (error.name === 'SequelizeUniqueConstraintError') {
      return res.status(400).json({ error: 'A proxy with this name already exists' });
    }
    res.status(500).json({ error: 'Failed to create upstream proxy' });
  }
});

// Update upstream proxy
router.put('/:id', authMiddleware, adminMiddleware, async (req: AuthRequest, res) => {
  try {
    const proxy = await UpstreamProxy.findByPk(req.params.id);

    if (!proxy) {
      return res.status(404).json({ error: 'Upstream proxy not found' });
    }

    const { 
      name, 
      proxyUrl, 
      type,
      provider,
      host,
      port,
      username,
      password,
      countryFilter,
      cityFilter,
      enabled,
      priority 
    } = req.body;

    // If new proxy URL is provided, parse it
    let finalHost = host;
    let finalPort = port;
    let finalUsername = username;
    let finalPassword = password;
    let finalProvider = provider;
    let finalType = type;
    
    if (proxyUrl !== undefined && proxyUrl !== proxy.proxyUrl) {
      if (proxyUrl) {
        const parsed = parseProxyUrl(proxyUrl);
        if (!parsed) {
          return res.status(400).json({ error: 'Invalid proxy URL format' });
        }
        finalHost = parsed.host;
        finalPort = parsed.port;
        finalUsername = parsed.username || finalUsername;
        finalPassword = parsed.password || finalPassword;
        
        if (!finalProvider) {
          const detected = detectProvider(proxyUrl);
          if (detected) {
            finalProvider = detected;
            finalType = PROXY_PROVIDERS[detected].type;
          }
        }
      }
    }

    await proxy.update({
      name: name !== undefined ? name : proxy.name,
      type: finalType !== undefined ? finalType : proxy.type,
      provider: finalProvider !== undefined ? finalProvider : proxy.provider,
      host: finalHost !== undefined ? finalHost : proxy.host,
      port: finalPort !== undefined ? finalPort : proxy.port,
      username: finalUsername !== undefined ? finalUsername : proxy.username,
      password: finalPassword !== undefined ? finalPassword : proxy.password,
      proxyUrl: proxyUrl !== undefined ? proxyUrl : proxy.proxyUrl,
      countryFilter: countryFilter !== undefined ? countryFilter?.toUpperCase() || null : proxy.countryFilter,
      cityFilter: cityFilter !== undefined ? cityFilter : proxy.cityFilter,
      country: countryFilter !== undefined ? countryFilter?.toUpperCase() || null : proxy.country,
      city: cityFilter !== undefined ? cityFilter : proxy.city,
      enabled: enabled !== undefined ? enabled : proxy.enabled,
      priority: priority !== undefined ? priority : proxy.priority,
    });

    // Regenerate Squid config
    try {
      const config = await generateUpstreamConfig();
      await writeFile(UPSTREAM_CONFIG_PATH, config);
      console.log('Upstream config regenerated');
    } catch (configError) {
      console.error('Failed to update Squid config:', configError);
    }

    res.json({
      ...proxy.toJSON(),
      password: undefined,
    });
  } catch (error) {
    console.error('Upstream update error:', error);
    res.status(500).json({ error: 'Failed to update upstream proxy' });
  }
});

// Delete upstream proxy
router.delete('/:id', authMiddleware, adminMiddleware, async (req: AuthRequest, res) => {
  try {
    const proxy = await UpstreamProxy.findByPk(req.params.id);

    if (!proxy) {
      return res.status(404).json({ error: 'Upstream proxy not found' });
    }

    await proxy.destroy();

    // Regenerate Squid config
    try {
      const config = await generateUpstreamConfig();
      await writeFile(UPSTREAM_CONFIG_PATH, config);
      console.log('Upstream config regenerated');
    } catch (configError) {
      console.error('Failed to update Squid config:', configError);
    }

    res.json({ message: 'Upstream proxy deleted' });
  } catch (error) {
    console.error('Upstream delete error:', error);
    res.status(500).json({ error: 'Failed to delete upstream proxy' });
  }
});

export default router;
