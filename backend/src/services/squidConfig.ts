import * as fs from 'fs';
import * as path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

// Path to dynamic Squid config managed by this service
const SQUID_CONF_DIR = process.env.SQUID_CONF_DIR || '/etc/squid/conf.d';
const SETTINGS_CONF_PATH = path.join(SQUID_CONF_DIR, 'settings.conf');

export interface SquidSettings {
  caching_enabled: boolean;
  max_object_size: number; // bytes
  cache_size: number; // bytes
  memory_cache_size: number; // bytes
  ssl_bump_enabled: boolean;
  aggressive_caching: boolean;
}

/**
 * Convert bytes to Squid size format (MB or GB)
 */
function bytesToSquidSize(bytes: number): string {
  const gb = bytes / (1024 * 1024 * 1024);
  if (gb >= 1 && Number.isInteger(gb)) {
    return `${gb} GB`;
  }
  const mb = Math.round(bytes / (1024 * 1024));
  return `${mb} MB`;
}

/**
 * Convert bytes to cache_dir size (in MB, no unit suffix)
 */
function bytesToCacheDirMB(bytes: number): number {
  return Math.round(bytes / (1024 * 1024));
}

/**
 * Generate Squid configuration snippet from settings
 */
export function generateSquidConfig(settings: SquidSettings): string {
  const lines: string[] = [
    '# Squache Dynamic Settings',
    '# Auto-generated by squache-backend - DO NOT EDIT MANUALLY',
    `# Generated at: ${new Date().toISOString()}`,
    '',
  ];

  // Caching settings
  if (!settings.caching_enabled) {
    lines.push('# Caching disabled');
    lines.push('cache deny all');
    lines.push('');
  }

  // Memory cache size
  lines.push(`# Memory cache: ${bytesToSquidSize(settings.memory_cache_size)}`);
  lines.push(`cache_mem ${bytesToSquidSize(settings.memory_cache_size)}`);
  lines.push('');

  // Maximum object size
  lines.push(`# Maximum cacheable object size: ${bytesToSquidSize(settings.max_object_size)}`);
  lines.push(`maximum_object_size ${bytesToSquidSize(settings.max_object_size)}`);
  lines.push('');

  // Maximum object size in memory (10% of memory cache, max 50MB)
  const maxObjInMemory = Math.min(
    Math.round(settings.memory_cache_size * 0.1),
    50 * 1024 * 1024
  );
  lines.push(`maximum_object_size_in_memory ${bytesToSquidSize(maxObjInMemory)}`);
  lines.push('');

  // Disk cache size - we need to use cache_dir but that requires a restart
  // Instead, we'll document the expected size
  lines.push(`# Disk cache size: ${bytesToSquidSize(settings.cache_size)}`);
  lines.push(`# NOTE: cache_dir size requires proxy restart to apply`);
  lines.push(`# Expected: cache_dir ufs /var/spool/squid ${bytesToCacheDirMB(settings.cache_size)} 16 256`);
  lines.push('');

  // Aggressive caching (refresh patterns)
  if (settings.aggressive_caching) {
    lines.push('# Aggressive caching enabled - override cache headers for static assets');
    lines.push('refresh_pattern -i \\.(gif|png|jpg|jpeg|ico|webp|svg|bmp|tiff)$ 10080 90% 43200 override-expire override-lastmod reload-into-ims ignore-reload ignore-no-store ignore-private');
    lines.push('refresh_pattern -i \\.(css|js|jsx|ts|tsx|mjs)$ 10080 90% 43200 override-expire override-lastmod reload-into-ims ignore-reload ignore-no-store ignore-private');
    lines.push('refresh_pattern -i \\.(woff|woff2|ttf|otf|eot)$ 10080 90% 43200 override-expire override-lastmod reload-into-ims ignore-reload ignore-no-store ignore-private');
    lines.push('refresh_pattern -i \\.(mp4|webm|avi|mov|mkv|flv|wmv|m4v)$ 10080 90% 43200 override-expire override-lastmod reload-into-ims ignore-reload ignore-no-store ignore-private');
    lines.push('refresh_pattern -i \\.(mp3|wav|ogg|flac|m4a|aac)$ 10080 90% 43200 override-expire override-lastmod reload-into-ims ignore-reload ignore-no-store ignore-private');
    lines.push('refresh_pattern -i \\.(pdf|doc|docx|xls|xlsx|ppt|pptx)$ 10080 90% 43200 override-expire override-lastmod reload-into-ims ignore-reload ignore-no-store ignore-private');
    lines.push('refresh_pattern -i \\.(zip|rar|7z|tar|gz|bz2)$ 10080 90% 43200 override-expire override-lastmod reload-into-ims ignore-reload ignore-no-store ignore-private');
  } else {
    lines.push('# Aggressive caching disabled - respect cache headers');
    lines.push('# Using default refresh patterns from main config');
  }
  lines.push('');

  // SSL bump settings
  if (!settings.ssl_bump_enabled) {
    lines.push('# SSL bumping disabled - splice all HTTPS traffic');
    lines.push('ssl_bump splice all');
  } else {
    lines.push('# SSL bumping enabled (configured in main squid.conf)');
  }
  lines.push('');

  return lines.join('\n');
}

/**
 * Write Squid configuration to the shared config directory
 */
export async function writeSquidConfig(settings: SquidSettings): Promise<void> {
  const config = generateSquidConfig(settings);

  // Ensure directory exists
  await fs.promises.mkdir(SQUID_CONF_DIR, { recursive: true });

  // Write config file
  await fs.promises.writeFile(SETTINGS_CONF_PATH, config, 'utf-8');

  console.log(`Squid config written to ${SETTINGS_CONF_PATH}`);
}

/**
 * Signal Squid to reload configuration
 * Uses squid -k reconfigure which is a graceful reload
 */
export async function reloadSquid(): Promise<{ success: boolean; message: string }> {
  try {
    // Try to signal Squid to reconfigure
    // This works if we have access to the Squid process
    // In Docker, we may need to use docker exec or a signal
    
    // First try direct squid reconfigure command
    try {
      await execAsync('squid -k reconfigure 2>&1 || true', { timeout: 5000 });
      return { success: true, message: 'Squid configuration reloaded' };
    } catch (directError) {
      // If direct command fails, try via squidclient
      try {
        await execAsync('squidclient -h squache-proxy mgr:offline_toggle 2>&1 || true', { timeout: 5000 });
        return { success: true, message: 'Squid configuration reload requested' };
      } catch (clientError) {
        // Can't reload directly, but config is written
        return { 
          success: true, 
          message: 'Configuration saved. Squid will apply changes on next restart.' 
        };
      }
    }
  } catch (error) {
    console.error('Failed to reload Squid:', error);
    return { 
      success: true, 
      message: 'Configuration saved. Manual Squid restart may be required.' 
    };
  }
}

/**
 * Parse config from database format to SquidSettings
 */
export function parseConfigToSettings(config: Record<string, string>): SquidSettings {
  return {
    caching_enabled: config.caching_enabled !== 'false',
    max_object_size: parseInt(config.max_object_size) || 1073741824,
    cache_size: parseInt(config.cache_size) || 10737418240,
    memory_cache_size: parseInt(config.memory_cache_size) || 536870912,
    ssl_bump_enabled: config.ssl_bump_enabled !== 'false',
    aggressive_caching: config.aggressive_caching !== 'false',
  };
}

/**
 * Apply settings from database to Squid
 */
export async function applySettings(config: Record<string, string>): Promise<{ success: boolean; message: string }> {
  const settings = parseConfigToSettings(config);
  
  await writeSquidConfig(settings);
  
  return await reloadSquid();
}
